from flask import Blueprint, jsonify, request
from models import db, Image, Video, Song, User
from sqlalchemy import func, desc
from datetime import datetime
import os

# Blueprint untuk landing content API
landing_content_bp = Blueprint('landing_content', __name__)

@landing_content_bp.route('/api/landing/images', methods=['GET'])
def get_landing_images():
    """Mengambil gambar terbaru dari database untuk landing page"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 8, type=int)
        category = request.args.get('category', None)
        featured_only = request.args.get('featured', False, type=bool)
        
        # Query untuk mengambil gambar dengan user info
        query = db.session.query(Image, User).join(User, Image.user_id == User.id)
        
        # Filter berdasarkan kategori jika ada
        if category and category != 'all':
            # Anda bisa menambahkan kolom category di tabel images jika diperlukan
            # query = query.filter(Image.category == category)
            pass
        
        # Filter featured jika diperlukan
        if featured_only:
            # Anda bisa menambahkan kolom is_featured di tabel images jika diperlukan
            # query = query.filter(Image.is_featured == True)
            pass
        
        # Order by created_at desc
        query = query.order_by(desc(Image.created_at))
        
        # Pagination
        total = query.count()
        start = (page - 1) * per_page
        results = query.offset(start).limit(per_page).all()
        
        # Convert to dict
        images_data = []
        for image, user in results:
            # Validasi URL gambar
            image_url = image.image_url if image.image_url and image.image_url.startswith('http') else None
            
            # Tentukan kategori berdasarkan caption saja (model_name tidak ada di database)
            category = determine_image_category(image.caption or '', '')
            
            images_data.append({
                'id': image.id,
                'title': image.caption or 'AI Generated Image',
                'description': f'Generated by {user.username if user else "Anonymous"}',
                'image_url': image_url or 'https://via.placeholder.com/400x300/6366f1/ffffff?text=Sample+Image',
                'category': category,
                'created_by': f'@{user.username}' if user else '@anonymous',
                'created_at': image.created_at.isoformat() if image.created_at else None,
                'is_featured': False,  # Default value
                'tags': extract_tags_from_caption(image.caption or ''),
                'user': {
                    'id': user.id if user else None,
                    'username': user.username if user else 'Anonymous',
                    'avatar_url': user.avatar_url if user else '/static/assets/image/default.jpg'
                }
            })
        
        return jsonify({
            'success': True,
            'data': images_data,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total,
                'pages': (total + per_page - 1) // per_page,
                'has_next': start + per_page < total,
                'has_prev': page > 1
            }
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@landing_content_bp.route('/api/landing/music', methods=['GET'])
def get_landing_music():
    """Mengambil musik terbaru dari database untuk landing page"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 6, type=int)
        genre = request.args.get('genre', None)
        featured_only = request.args.get('featured', False, type=bool)
        
        # Query untuk mengambil musik dengan user info
        query = db.session.query(Song, User).join(User, Song.user_id == User.id)
        
        # Filter berdasarkan genre jika ada
        if genre and genre != 'all':
            # Anda bisa menambahkan kolom genre di tabel songs jika diperlukan
            # query = query.filter(Song.genre == genre)
            pass
        
        # Filter featured jika diperlukan
        if featured_only:
            # Anda bisa menambahkan kolom is_featured di tabel songs jika diperlukan
            # query = query.filter(Song.is_favorite == True)
            pass
        
        # Order by created_at desc
        query = query.order_by(desc(Song.created_at))
        
        # Pagination
        total = query.count()
        start = (page - 1) * per_page
        results = query.offset(start).limit(per_page).all()
        
        # Convert to dict
        music_data = []
        for song, user in results:
            # Validasi URL
            audio_url = song.audio_url if song.audio_url and song.audio_url.startswith('http') else None
            image_url = song.image_url if song.image_url and song.image_url.startswith('http') else None
            
            # Tentukan genre berdasarkan model_name atau prompt
            genre = determine_music_genre(song.model_name or '', song.prompt or '')
            
            # Format durasi
            duration = format_duration(song.duration)
            
            music_data.append({
                'id': song.id,
                'title': song.title or 'AI Generated Music',
                'description': song.prompt or 'AI generated music track',
                'music_url': audio_url or '#',
                'cover_image_url': image_url or 'https://via.placeholder.com/300x300/10b981/ffffff?text=Music+Cover',
                'genre': genre,
                'duration': duration,
                'created_by': f'@{user.username}' if user else '@anonymous',
                'created_at': song.created_at.isoformat() if song.created_at else None,
                'is_featured': song.is_favorite or False,
                'tags': extract_tags_from_prompt(song.prompt or ''),
                'user': {
                    'id': user.id if user else None,
                    'username': user.username if user else 'Anonymous',
                    'avatar_url': user.avatar_url if user else '/static/assets/image/default.jpg'
                }
            })
        
        return jsonify({
            'success': True,
            'data': music_data,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total,
                'pages': (total + per_page - 1) // per_page,
                'has_next': start + per_page < total,
                'has_prev': page > 1
            }
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@landing_content_bp.route('/api/landing/categories', methods=['GET'])
def get_image_categories():
    """Mengambil daftar kategori gambar dari database"""
    try:
        # Ambil semua caption dan model_name untuk menentukan kategori
        images = db.session.query(Image.caption, Image.model_name).filter(
            Image.caption.isnot(None)
        ).limit(100).all()
        
        categories = set()
        for caption, model_name in images:
            category = determine_image_category(caption or '', model_name or '')
            if category:
                categories.add(category)
        
        # Tambahkan kategori default
        default_categories = ['Portrait', 'Landscape', 'Abstract', 'Sci-Fi', 'Digital', 'Art', 'Nature']
        categories.update(default_categories)
        
        return jsonify({
            'success': True,
            'data': list(categories)
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@landing_content_bp.route('/api/landing/genres', methods=['GET'])
def get_music_genres():
    """Mengambil daftar genre musik dari database"""
    try:
        # Ambil semua model_name dan prompt untuk menentukan genre
        songs = db.session.query(Song.model_name, Song.prompt).filter(
            Song.model_name.isnot(None)
        ).limit(100).all()
        
        genres = set()
        for model_name, prompt in songs:
            genre = determine_music_genre(model_name or '', prompt or '')
            if genre:
                genres.add(genre)
        
        # Tambahkan genre default
        default_genres = ['Electronic', 'Ambient', 'Synthwave', 'Bass', 'Rock', 'Jazz', 'Classical', 'Pop']
        genres.update(default_genres)
        
        return jsonify({
            'success': True,
            'data': list(genres)
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@landing_content_bp.route('/api/landing/stats', methods=['GET'])
def get_landing_stats():
    """Mengambil statistik untuk landing page"""
    try:
        # Hitung total konten
        total_images = Image.query.count()
        total_videos = Video.query.count()
        total_songs = Song.query.count()
        total_users = User.query.count()
        
        # Hitung konten terbaru (24 jam terakhir)
        from datetime import datetime, timedelta
        yesterday = datetime.utcnow() - timedelta(days=1)
        
        recent_images = Image.query.filter(Image.created_at >= yesterday).count()
        recent_videos = Video.query.filter(Video.created_at >= yesterday).count()
        recent_songs = Song.query.filter(Song.created_at >= yesterday).count()
        
        return jsonify({
            'success': True,
            'data': {
                'total_images': total_images,
                'total_videos': total_videos,
                'total_songs': total_songs,
                'total_users': total_users,
                'recent_images': recent_images,
                'recent_videos': recent_videos,
                'recent_songs': recent_songs,
                'total_content': total_images + total_videos + total_songs
            }
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

# Helper functions
def determine_image_category(caption, model_name):
    """Menentukan kategori gambar berdasarkan caption dan model_name"""
    text = (caption + ' ' + model_name).lower()
    
    if any(word in text for word in ['portrait', 'face', 'person', 'human', 'character']):
        return 'Portrait'
    elif any(word in text for word in ['landscape', 'mountain', 'forest', 'beach', 'nature', 'sky']):
        return 'Landscape'
    elif any(word in text for word in ['abstract', 'art', 'painting', 'colorful', 'pattern']):
        return 'Abstract'
    elif any(word in text for word in ['sci-fi', 'futuristic', 'cyberpunk', 'robot', 'space', 'alien']):
        return 'Sci-Fi'
    elif any(word in text for word in ['digital', 'vector', 'graphic', 'design', 'logo']):
        return 'Digital'
    elif any(word in text for word in ['animal', 'pet', 'wildlife', 'bird', 'cat', 'dog']):
        return 'Nature'
    else:
        return 'Art'

def determine_music_genre(model_name, prompt):
    """Menentukan genre musik berdasarkan model_name dan prompt"""
    text = (model_name + ' ' + prompt).lower()
    
    if any(word in text for word in ['electronic', 'synth', 'techno', 'house', 'edm']):
        return 'Electronic'
    elif any(word in text for word in ['ambient', 'chill', 'relaxing', 'peaceful', 'meditation']):
        return 'Ambient'
    elif any(word in text for word in ['synthwave', 'retro', '80s', 'nostalgic', 'vaporwave']):
        return 'Synthwave'
    elif any(word in text for word in ['bass', 'heavy', 'dubstep', 'trap', 'drum']):
        return 'Bass'
    elif any(word in text for word in ['rock', 'guitar', 'electric', 'metal', 'punk']):
        return 'Rock'
    elif any(word in text for word in ['jazz', 'saxophone', 'trumpet', 'blues', 'swing']):
        return 'Jazz'
    elif any(word in text for word in ['classical', 'orchestra', 'piano', 'violin', 'symphony']):
        return 'Classical'
    elif any(word in text for word in ['pop', 'catchy', 'melodic', 'mainstream']):
        return 'Pop'
    else:
        return 'Electronic'

def format_duration(duration):
    """Format durasi dari detik ke format MM:SS"""
    if not duration:
        return '0:00'
    
    try:
        # Jika duration sudah dalam format string
        if isinstance(duration, str) and ':' in duration:
            return duration
        
        # Jika duration dalam detik (integer/float)
        duration_seconds = int(float(duration))
        minutes = duration_seconds // 60
        seconds = duration_seconds % 60
        return f"{minutes}:{seconds:02d}"
    except:
        return '0:00'

def extract_tags_from_caption(caption):
    """Ekstrak tags dari caption gambar"""
    if not caption:
        return []
    
    # Kata kunci yang umum untuk tags
    keywords = ['ai', 'generated', 'art', 'digital', 'creative', 'beautiful', 'amazing', 'stunning', 'colorful', 'vibrant']
    tags = []
    
    caption_lower = caption.lower()
    for keyword in keywords:
        if keyword in caption_lower:
            tags.append(keyword)
    
    # Ambil beberapa kata dari caption sebagai tags
    words = caption.split()[:3]  # Ambil 3 kata pertama
    tags.extend([word.lower() for word in words if len(word) > 3])
    
    return list(set(tags))[:5]  # Maksimal 5 tags

def extract_tags_from_prompt(prompt):
    """Ekstrak tags dari prompt musik"""
    if not prompt:
        return []
    
    # Kata kunci yang umum untuk musik
    keywords = ['music', 'song', 'melody', 'beat', 'rhythm', 'instrumental', 'vocal', 'electronic', 'ambient']
    tags = []
    
    prompt_lower = prompt.lower()
    for keyword in keywords:
        if keyword in prompt_lower:
            tags.append(keyword)
    
    # Ambil beberapa kata dari prompt sebagai tags
    words = prompt.split()[:3]  # Ambil 3 kata pertama
    tags.extend([word.lower() for word in words if len(word) > 3])
    
    return list(set(tags))[:5]  # Maksimal 5 tags

# Register blueprint
def register_landing_content_api(app):
    app.register_blueprint(landing_content_bp)
